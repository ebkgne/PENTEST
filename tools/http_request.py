import subprocess,re, keyboard, threading, urllib.request,os, chardet, datetime, random, ast,json,math,sys

from datetime import datetime
from urllib.parse import urlparse

def payloadify(string,payloads=[]):
    
    if not type(payloads) == list: payloads = [payloads]
    
    for x in re.findall(r"\.\.(\d+)\.\.",string): 
        i = int(x)-1

        string = string.replace(".."+x+"..",(urllib.parse.quote(payloads[i]) if i < len(payloads) else "" ))
        
    return string 

from http_packet import HTTP_Packet

DEBUG = False

DEFAULT_USERAGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36"
DEFAULT_USERAGENT = "MichMich"

STOP_FLAG = False
lulz = 0    
class HTTP_Request:
    
    # Request data
    useragent_str = ""
    referer_str = ""
    url_str = ""
    post_str = ""
    cookies_str = ""
    flags = ""
    DEBUG = False
    
# Rules
    follow = 0
    referer_auto = False
    rules = []
    
    # Private data
    url_location = ""
    url_path = ""
    
    # ???
    from_list_result = []
    
    def __init__( t, url = "", post = "", flags = "-m 1", useragent = DEFAULT_USERAGENT ):
        
        if not len(url): return
        
        t.post_str = post
        t.flags = flags
        t.useragent_str = useragent
        
        t.set_url(url)

    def set_unknow_page(t, val = "NOWAYTHISEXIST", ext="/"):
        temp_url = t.url_str
        # temp_post = t.post_str
        t.url_str = (t.url_location+"/..1..")
        x = t.query(val+ext)
        t.default_ultra_random = [x.code, x.length, x.title]
        t.url_str = temp_url

    def set_url(t, url):
        
        t.url_str = url
        
        # Parse URL
        urlparsed = urlparse(url)
        t.url_location = urlparsed.scheme+"://"+urlparsed.netloc
        t.url_path = urlparsed.path 
        t.url_path += ("?"+urlparsed.query if urlparsed.query else "")
        t.url_path += ("#"+urlparsed.fragment if urlparsed.fragment else "")

    def get_cookies(t):
        r = t.query("GET SESSIONS COOKIES")
        out = ""
        for c in r.cookies:
            x = re.findall(r"(\w+)=(.+)",c)
            if x:
                out = x[0][0]+"="+x[0][1]+";"
                if re.search("(ASP|PHP).?SESSION",x[0][0],re.I): 
                    if len(t.cookies_str) and t.cookies_str[-1].strip() != ";": t.cookies_str += ";"
                    t.cookies_str += out
                    break
        return out
              
        
    MAX_CHANGED = False
    
    callback = lambda x,t,r: print("oops")
    
    MAX_THREADS = 20
    threads_queue = []
    threads_lock = threading.Lock()
    threads_count = 0
    threads_results = []     
        
        
    def process(t):
        global lulz, STOP_FLAG
        while not STOP_FLAG:
            
            if len(t.threads_queue) == 0:
                if t.threads_count == 0: break
                continue 
            start_time = datetime.now()
            
            payloads = t.threads_queue.pop(0)
            
            command = "curl -v -s -sS"
            
            if t.follow:                command += " -L --max-redirs "+str(t.follow)
            if len(t.useragent_str):    command += ' -H "User-Agent:'+payloadify(t.useragent_str,payloads)+'"'
            if len(t.cookies_str):      command += " -b \""+t.cookies_str+"\""
            if len(t.flags):            command += " "+t.flags
            if len(t.post_str):         command += " --request POST -X POST"
            # if len(t.post_str):         command += " --request POST -X GET" # need to fix this and line above
            if len(t.referer_str):      command += ' -e "'+payloadify(t.referer_str,payloads)+'"'
            if len(t.post_str):         command += ' -d "'+payloadify(t.post_str,payloads)+'"'
                # for big POST datas use   following:
                # with open(path_to_logs+"temp_data.txt", 'w') as file: file.write(payloadify(t.post_str,payloads))  
                # command += ' -X POST -d @'+path_to_logs+"temp_data.txt"

            command += " \""+ payloadify(t.url_str.replace("\"","\\\""),payloads)+ "\""
            
            if t.DEBUG: print(command) 
            lulz+=1

            results = subprocess.run("echo " + json.dumps({ "count":lulz, "payload":urllib.parse.unquote(str(payloads)) })+" && " + command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)

            # beyond 5s response time: divide max reqs
            if ((datetime.now() - start_time).total_seconds()>5 and t.MAX_CHANGED): 
                t.MAX_CHANGED = False
                # t.MAX_REQUEST = math.ceil(t.MAX_REQUEST*.5)
                # print("MAX_REQUEST: "+str(t.MAX_REQUEST))
            
            with t.threads_lock:

                r = HTTP_Packet(results)
                
                if r.code: # could be removed ?

                    if not r.code in t.rules:
                        c = 0
                        c += t.default_ultra_random[0] == r.code
                        c += t.default_ultra_random[1] == r.length
                        c += t.default_ultra_random[2] == r.title
                        if c < 2:
                            t.from_list_result.append(r)
                            t.callback(t,r)
      
                t.threads_results.append(r)           
                t.threads_count -= 1
                
        return t.threads_results         

    def on_key_pressed(t, event): 

        if event.scan_code == 44: 
            # sys.stdout.write('\033[F')  # Move cursor to the beginning of the last line
            # sys.stdout.write('\033[K')  # Clear the line
            # sys.stdout.write(str(t.threads_count))  # Print the new text
            # sys.stdout.flush()    
            print(str(t.threads_count))
        if event.scan_code == 1: 
            global STOP_FLAG
            STOP_FLAG = True
            os._exit(1)
        # print("keycode:"+str(event.scan_code))
    
    default_ultra_random = [0,0,0]
    
    def auto_referer(t): t.referer = t.url_location
  
    def from_list(t,lst):

        keyboard.on_press(t.on_key_pressed)
        
        threads = []
        t.threads_results = []
        
        for command in lst:
            t.threads_queue.append(command) 
            t.threads_count += 1
            
        for _ in range(t.MAX_THREADS):
            thread = threading.Thread(target=t.process)
            thread.start()
            threads.append(thread)

        for thread in threads: thread.join()

        return t.threads_results
        
    def query(t,payload): return t.from_list([payload])[0]
    
    def from_file(t, file):
        
        pending = []
        
        with open(file, 'rb') as file2: enc = chardet.detect(file2.read())["encoding"]

        with open(file, 'r', encoding=enc) as file: 
            
            for line in file: pending.append(str(line.strip()))
    
        return  t.from_list(pending)
